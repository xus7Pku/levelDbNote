包 filter 提供过滤器数据结构；



filter 的作用是为一系列的 key 创建过滤器；

filter 被用来判断某一 key 是否在已有的键集合中；

许多情况下，过滤器都能够减少磁盘的访问次数，即能够提早确定 key 不存在；



filter.go 定义了 filter 需要实现的接口，可用于用户自行编写过滤器；

```go
// Buffer 封装了 Alloc、Write 和 WriteByte 方法
// Buffer 是用来存储位图的地方
type Buffer interface {
	// Alloc allocs n bytes of slice from the buffer. This also advancing
	// write offset.
	// Alloc 在 buffer 中申请预留 n 字节的空间
	Alloc(n int) []byte

	// Write appends the contents of p to the buffer.
	// Write 添加 p 到 buf 中
	Write(p []byte) (n int, err error)

	// WriteByte appends the byte c to the buffer.
	// WriteByte 添加单个字节到 buf 中
	WriteByte(c byte) error
}
```

```go
// Filter 是过滤器
type Filter interface {
	// Name 返回过滤方法的名称
	//
	// Note that if the filter encoding changes in an incompatible way,
	// the name returned by this method must be changed. Otherwise, old
	// incompatible filters may be passed to methods of this type.
	// 注意到如果 filter 的过滤方式以不兼容的方式改变，那么 name 也要进行改变
	// 否则，不兼容的同名 filter 会出现问题
	//
	Name() string

	// NewGenerator creates a new filter generator.
	// NewGenerator 创建新的 filter 生成器
	NewGenerator() FilterGenerator

	// Contains returns true if the filter contains the given key.
	// Contains 返回 true 如果 filter 包含了给定的 key
	//
	// The filter are filters generated by the filter generator.
	// filter 是生成器生成的 filter
	Contains(filter, key []byte) bool
}
```

```go
// FilterGenerator 是 filter 生成器
type FilterGenerator interface {
	// Add 将 key 加入到 filter 生成器中
	// key 在调用 Add 后就不能进行使用，要再次使用需要拷贝一份,进行修改会产生不可知的后果
	Add(key []byte)

	// Generate 产生 filter 基于目前已有的 key
	// 调用 Generate 之后 filter 生成器可能会被重置，取决于具体的实现
	Generate(b Buffer)
}
```



与布隆过滤器的准确率有关的参数：

*   哈希函数的个数 k；
*   布隆过滤器数组的容量 m；
*   布隆过滤器插入的数据数量 n；

主要的数学结论有：

*   当 k=ln2*(m/n) 时，布隆过滤器获得最优的准确性；
*   在哈希函数的个数取到最优时，要让错误率不超过є，m至少需要取到最小值的1.44倍；



```go
// bloomHash 对 key 进行哈希编码，具体的编码方式不太清楚
func bloomHash(key []byte) uint32 {
	return util.Hash(key, 0xbc9f1d34)
}
```

```go
// bloomFilter 的值代表的是布隆过滤器数组的容量 m 和插入数据数量 n 的比值
// 通常情况下，该值大于 1.44 即可，一般默认为 10
type bloomFilter int

// Name: 布隆过滤器序列化其参数，并且兼容，因此名称不需要改变
func (bloomFilter) Name() string {
	return "leveldb.BuiltinBloomFilter"
}

// Contains 检验 filter（字节数组）是否可能包含 key
func (f bloomFilter) Contains(filter, key []byte) bool {
	// filter 中的字节数量
	// 最后一个字节是 k 本身，也就是该 filter 中 key 进行的哈希次数
	nBytes := len(filter) - 1
	if nBytes < 1 {
		return false
	}
    
	// filter 中位图的位数
	nBits := uint32(nBytes * 8)

	// Use the encoded k so that we can read filters generated by
	// bloom filters created using different parameters.
	k := filter[nBytes]
	if k > 30 {
		// 是预留出来，可以直接通过校验的...？
		return true
	}

	// 计算了 1 次哈希，并通过计算来假装进行了 k 次哈希
	kh := bloomHash(key)
	// kh 的右边 17 位旋转了一下，用来作为 k 次哈希的基准
	delta := (kh >> 17) | (kh << 15) // Rotate right 17 bits
	// 进行 k 次哈希
	for j := uint8(0); j < k; j++ {
		// 计算该哈希结果对应位图中的哪一位
		bitpos := kh % nBits
		// 对应到位图中看是不是记录为 1，不为 1 就返回 false
		if (uint32(filter[bitpos/8]) & (1 << (bitpos % 8))) == 0 {
			return false
		}
		kh += delta
	}
	return true
}

// NewGenerator 生成新的 FilterGenerator
func (f bloomFilter) NewGenerator() FilterGenerator {
	// Round down to reduce probing cost a little bit.
	// 指定哈希函数的个数为 k
	k := uint8(f * 69 / 100) // 0.69 =~ ln(2)
	if k < 1 {
		k = 1
	} else if k > 30 {
		k = 30
	}
	// n 为 bitsPerKey，k 为哈希函数的次数
	return &bloomFilterGenerator{
		n: int(f),
		k: k,
	}
}
```

```go
// bloomFilterGenerator 布隆过滤器的生成器
type bloomFilterGenerator struct {
	// bitsPerKey
	n int
	// 哈希函数的次数
	k uint8

	keyHashes []uint32
}

// bloomFilterGenerator.Add 增加 key 的哈希到 keyHashes 中
func (g *bloomFilterGenerator) Add(key []byte) {
	// Use double-hashing to generate a sequence of hash values.
	// See analysis in [Kirsch,Mitzenmacher 2006].
	g.keyHashes = append(g.keyHashes, bloomHash(key))
}

// bloomFilterGenerator.Generate 产生过滤器到 b 的字节数组中
func (g *bloomFilterGenerator) Generate(b Buffer) {
	// 计算布隆过滤器数组的容量，包括 bits 和 bytes
	// g.keyHashes 是哈希的数量，等于插入的数据量，g.n 是数组容量和插入数据量的比值
    
	nBits := uint32(len(g.keyHashes) * g.n)
	// 对于小的 n，会出现问题？即误判率过高，这是有数学依据的
	// 通过直接赋值来解决该问题
	if nBits < 64 {
		nBits = 64
	}
	nBytes := (nBits + 7) / 8
	nBits = nBytes * 8

	// dest 在 b 中预留 nBytes+1 的空间
	dest := b.Alloc(int(nBytes) + 1)
	// 将哈希次数放在最后一个字节当中
	dest[nBytes] = g.k
	for _, kh := range g.keyHashes {
		// 对于每个 hash 值，都进行 k 次的旋转，并存储到位图当中
		delta := (kh >> 17) | (kh << 15) // Rotate right 17 bits
		for j := uint8(0); j < g.k; j++ {
			bitpos := kh % nBits
			dest[bitpos/8] |= (1 << (bitpos % 8))
			kh += delta
		}
	}

	// 清空 g.keyHashes
	g.keyHashes = g.keyHashes[:0]
}

// NewBloomFilter 创建新的初始化的布隆过滤器，位图位数 m / 容量 n 就是 bitsPerKey
// 由于 bitsPerKey 对于任一 m/n 的布隆过滤器都有独立性
// 因此布隆过滤器在更改 bitsPerKey 时前面的过滤器会向后兼容
// 这意味着在更改参数时不会遇到太大的性能损失
// 更多有关信息可以参考 opt.Options.Filter 文档
func NewBloomFilter(bitsPerKey int) Filter {
	return bloomFilter(bitsPerKey)
}

```

